Download Link: https://assignmentchef.com/product/solved-cs361-homework3-write-your-own-shell
<br>
One of the fundamental functionalities of Linux (and Linux-like OSs) is the ability to pipe commands. When the | character is used in a shell between two commands, the shell takes the output from the first command and “pipes” it to the second command as the input. You can try it yourself! If you run the command ls -la / | grep tmp on systems1, you should be able to see only the tmp directory output from ls -la. This is because you gave grep, a common search tool, the output of ls -la directly. There are many more applications of piping but that is for you to discover as necessary in your adventures/projects/jobs/etc etc etc.

<h1>The programming part</h1>

For this assignment you are to write a simple program that will act as a shell. The program should:

Display a command prompt and read in a command line from the user (the prompt must be CS361 &gt;, otherwise it cannot be detected by the test script)  Your shell must support basic piping like the unix shell.

<ol>

 <li>$ command Run command, with stdin and stdout connected to their usual files. When command finishes, the parent should output pid:%d status:%d
 (with the proper relevant values inserted into the format string), and then print the prompt again and wait for more input.</li>

 <li><a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1">$ command1 | command2</a><a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1"> Run</a> command1 as in #1, but redirects the output of</li>

</ol>

<a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1"><sup>CS 361 Summer 202</sup></a><a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1">command1 as input to comman</a><a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1"><sup>0</sup></a> d2. Note th<a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1">at ther</a><a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1">Home</a> e s<a href="https://sites.google.com/uic.edu/cs361summer2020/schedule?authuser=1">hould be </a><a href="https://sites.google.com/uic.edu/cs361summer2020/schedule?authuser=1">Schedule</a>tw<a href="https://sites.google.com/uic.edu/cs361summer2020/homeworks?authuser=1">o instances of</a><a href="https://sites.google.com/uic.edu/cs361summer2020/homeworks?authuser=1">Homeworks</a> <span style="text-decoration: line-through;">p</span>id:%d status:%d
 output.

<ol start="3">

 <li>$ command1 ; command2 Run command1 as in #1, wait for it to finish, and then run command 2 as in #1.</li>

</ol>

Also…

Your shell should handle the following signals:

<strong>SIGINT</strong> – Generated by Ctrl-C. This signal allows a user to terminate a running program. Your shell should not exit when user presses Ctrl-C or the process receives SIGINT but simply report that the SIGINT signal has been received by the shell. If the process receives SIGINT, you must print the string “caught sigint” on a line by itself, and then show the prompt again.

<strong> SIGTSTP</strong> – Generated by Ctrl-Z. This signal allows a user to terminate a running program. Your shell should not exit when user presses Ctrl-Z or the process receives SIGTSTP but simply report that the SIGTSTP signal has been received by the shell. If your shell receives SIGTSTP, you must print the string “caught sigtstp” on a line by itself, and then show the prompt again.

The shell does NOT need to support background processes, running more than one child at a time, or handling multiple chained pipes. <strong>Essentially, if anything not matching the use cases/requirements above is in question, you probably do not have to do it.</strong>

Due to the breadth of this assignment, it is difficult to clarify every case in writing. Please ask in office hours or on Piazza if you have questions or need clarification.

<h1>Tips for primary components</h1>

Parse the command line into arguments, creating an array of character pointers, where array[0] points to the actual command and rest of the array elements point to the arguments to the command (Similar to main()’s argv[])

Fork off a child and have the child load the requested program by passing the argument vector created in step 2 to exec() family of system calls. The parent should report the PID of the child before proceeding to the next step. (report means you are required to return strings contain “pid” and “status”, e.g. pid:11111 status:0)

Wait for the child to complete executing and report why it ended (exited or uncaught signal) and its exit value if available.

Repeat the first step forever until the user enters the command exit

<strong>Your personal repository</strong>

<h1>                    p                   p           y</h1>

No<a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1">te that there is</a><a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1"><sup>CS 361 Summer 202</sup></a> <a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1"><em>no</em></a><a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1"> skeleton code f</a><a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1"><sup>0</sup></a> or the home<a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1">work, y</a><a href="https://sites.google.com/uic.edu/cs361summer2020/home?authuser=1"><sup>Home</sup></a> o<a href="https://sites.google.com/uic.edu/cs361summer2020/schedule?authuser=1">u can find </a><a href="https://sites.google.com/uic.edu/cs361summer2020/schedule?authuser=1"><sup>Schedule</sup></a>the<a href="https://sites.google.com/uic.edu/cs361summer2020/homeworks?authuser=1"> repository fo</a><a href="https://sites.google.com/uic.edu/cs361summer2020/homeworks?authuser=1"><sup>Homeworks</sup></a> r hw3 <a href="https://www.google.com/url?q=https%3A%2F%2Fclassroom.github.com%2Fa%2F7aUmFG0z&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGBN_3JNXvHHj9HNaOMKMtG1rtSkA">here</a> (this is an empty repository, start by creating a file named “hw3.c” and add it to your github repository). Going to lab sections is highly advisable, as the TAs have been and will be explaining basics of getting started with a shell. Both the lab section code, as well as code found in the book or book slides, are “fair game” from which to begin your coding. Previous solutions, or other students’ work, are off limits and any cheating will be prosecuted to the fullest extent of university rules. <em>There are solutions on the Internet.</em> If we find you using them, we will give you an F in the class. Don’t look at them, don’t use them. It is not worth it.

<h1>Requirements</h1>

See above, but here is a summary:

<ol>

 <li>Display a command prompt (CS361 &gt;) and read in a command line from the user</li>

 <li>Handle $ command (run command, with stdin and stdout connected to their usual files, must additionally output pid:%d status:%d
, then continue)</li>

 <li>Handle $ command1 | command2 (run command1 as in #1, but redirects the output of command1 as input to command2, then continue)</li>

 <li>Handle $ command1 ; command2 (run command1 as in #1, wait for it to finish, and then run command 2 as in #1, then continue)</li>

 <li>Handle SIGINT – Generated by Ctrl-C (print “caught sigint” and then continue)</li>

 <li>Handle SIGTSTP – Generated by Ctrl-Z (print “caught sigtstp” and then continue)</li>

</ol>

It is <strong>highly</strong> recommended you develop and test your code on systems1 or a similar Linux environment. This is simply to ensure standardization of comparisons between our and your tests whilst you are developing your code.